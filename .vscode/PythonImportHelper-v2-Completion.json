[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_origin",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "model_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "model_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "app.llm",
        "description": "app.llm",
        "isExtraImport": true,
        "detail": "app.llm",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "app.llm",
        "description": "app.llm",
        "isExtraImport": true,
        "detail": "app.llm",
        "documentation": {}
    },
    {
        "label": "LLM",
        "importPath": "app.llm",
        "description": "app.llm",
        "isExtraImport": true,
        "detail": "app.llm",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "AgentState",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Memory",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "ToolCall",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "AgentState",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Memory",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "AgentState",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "ToolCall",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "AgentState",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "app.schema",
        "description": "app.schema",
        "isExtraImport": true,
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "ToolCallAgent",
        "importPath": "app.agent.toolcall",
        "description": "app.agent.toolcall",
        "isExtraImport": true,
        "detail": "app.agent.toolcall",
        "documentation": {}
    },
    {
        "label": "ToolCallAgent",
        "importPath": "app.agent.toolcall",
        "description": "app.agent.toolcall",
        "isExtraImport": true,
        "detail": "app.agent.toolcall",
        "documentation": {}
    },
    {
        "label": "ToolCallAgent",
        "importPath": "app.agent.toolcall",
        "description": "app.agent.toolcall",
        "isExtraImport": true,
        "detail": "app.agent.toolcall",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_PROMPT",
        "importPath": "app.prompt.manus",
        "description": "app.prompt.manus",
        "isExtraImport": true,
        "detail": "app.prompt.manus",
        "documentation": {}
    },
    {
        "label": "SYSTEM_PROMPT",
        "importPath": "app.prompt.manus",
        "description": "app.prompt.manus",
        "isExtraImport": true,
        "detail": "app.prompt.manus",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "ToolCollection",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "PlanningTool",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "ToolCollection",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "Bash",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "StrReplaceEditor",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "ToolCollection",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "CreateChatCompletion",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "ToolCollection",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "PlanningTool",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool",
        "description": "app.tool",
        "isExtraImport": true,
        "detail": "app.tool",
        "documentation": {}
    },
    {
        "label": "BrowserUseTool",
        "importPath": "app.tool.browser_use_tool",
        "description": "app.tool.browser_use_tool",
        "isExtraImport": true,
        "detail": "app.tool.browser_use_tool",
        "documentation": {}
    },
    {
        "label": "FileSaver",
        "importPath": "app.tool.file_saver",
        "description": "app.tool.file_saver",
        "isExtraImport": true,
        "detail": "app.tool.file_saver",
        "documentation": {}
    },
    {
        "label": "GoogleSearch",
        "importPath": "app.tool.google_search",
        "description": "app.tool.google_search",
        "isExtraImport": true,
        "detail": "app.tool.google_search",
        "documentation": {}
    },
    {
        "label": "PythonExecute",
        "importPath": "app.tool.python_execute",
        "description": "app.tool.python_execute",
        "isExtraImport": true,
        "detail": "app.tool.python_execute",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_PROMPT",
        "importPath": "app.prompt.planning",
        "description": "app.prompt.planning",
        "isExtraImport": true,
        "detail": "app.prompt.planning",
        "documentation": {}
    },
    {
        "label": "PLANNING_SYSTEM_PROMPT",
        "importPath": "app.prompt.planning",
        "description": "app.prompt.planning",
        "isExtraImport": true,
        "detail": "app.prompt.planning",
        "documentation": {}
    },
    {
        "label": "BaseAgent",
        "importPath": "app.agent.base",
        "description": "app.agent.base",
        "isExtraImport": true,
        "detail": "app.agent.base",
        "documentation": {}
    },
    {
        "label": "BaseAgent",
        "importPath": "app.agent.base",
        "description": "app.agent.base",
        "isExtraImport": true,
        "detail": "app.agent.base",
        "documentation": {}
    },
    {
        "label": "BaseAgent",
        "importPath": "app.agent.base",
        "description": "app.agent.base",
        "isExtraImport": true,
        "detail": "app.agent.base",
        "documentation": {}
    },
    {
        "label": "BaseAgent",
        "importPath": "app.agent.base",
        "description": "app.agent.base",
        "isExtraImport": true,
        "detail": "app.agent.base",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_TEMPLATE",
        "importPath": "app.prompt.swe",
        "description": "app.prompt.swe",
        "isExtraImport": true,
        "detail": "app.prompt.swe",
        "documentation": {}
    },
    {
        "label": "SYSTEM_PROMPT",
        "importPath": "app.prompt.swe",
        "description": "app.prompt.swe",
        "isExtraImport": true,
        "detail": "app.prompt.swe",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "ReActAgent",
        "importPath": "app.agent.react",
        "description": "app.agent.react",
        "isExtraImport": true,
        "detail": "app.agent.react",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_PROMPT",
        "importPath": "app.prompt.toolcall",
        "description": "app.prompt.toolcall",
        "isExtraImport": true,
        "detail": "app.prompt.toolcall",
        "documentation": {}
    },
    {
        "label": "SYSTEM_PROMPT",
        "importPath": "app.prompt.toolcall",
        "description": "app.prompt.toolcall",
        "isExtraImport": true,
        "detail": "app.prompt.toolcall",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "BaseFlow",
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "isExtraImport": true,
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "FlowType",
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "isExtraImport": true,
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "BaseFlow",
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "isExtraImport": true,
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "PlanStepStatus",
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "isExtraImport": true,
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "FlowType",
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "isExtraImport": true,
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "PlanningFlow",
        "importPath": "app.flow.planning",
        "description": "app.flow.planning",
        "isExtraImport": true,
        "detail": "app.flow.planning",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "ToolError",
        "importPath": "app.exceptions",
        "description": "app.exceptions",
        "isExtraImport": true,
        "detail": "app.exceptions",
        "documentation": {}
    },
    {
        "label": "ToolError",
        "importPath": "app.exceptions",
        "description": "app.exceptions",
        "isExtraImport": true,
        "detail": "app.exceptions",
        "documentation": {}
    },
    {
        "label": "ToolError",
        "importPath": "app.exceptions",
        "description": "app.exceptions",
        "isExtraImport": true,
        "detail": "app.exceptions",
        "documentation": {}
    },
    {
        "label": "ToolError",
        "importPath": "app.exceptions",
        "description": "app.exceptions",
        "isExtraImport": true,
        "detail": "app.exceptions",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "CLIResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "CLIResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolFailure",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolResult",
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "isExtraImport": true,
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "Browser",
        "importPath": "browser_use",
        "description": "browser_use",
        "isExtraImport": true,
        "detail": "browser_use",
        "documentation": {}
    },
    {
        "label": "BrowserConfig",
        "importPath": "browser_use",
        "description": "browser_use",
        "isExtraImport": true,
        "detail": "browser_use",
        "documentation": {}
    },
    {
        "label": "BrowserContext",
        "importPath": "browser_use.browser.context",
        "description": "browser_use.browser.context",
        "isExtraImport": true,
        "detail": "browser_use.browser.context",
        "documentation": {}
    },
    {
        "label": "DomService",
        "importPath": "browser_use.dom.service",
        "description": "browser_use.dom.service",
        "isExtraImport": true,
        "detail": "browser_use.dom.service",
        "documentation": {}
    },
    {
        "label": "ValidationInfo",
        "importPath": "pydantic_core.core_schema",
        "description": "pydantic_core.core_schema",
        "isExtraImport": true,
        "detail": "pydantic_core.core_schema",
        "documentation": {}
    },
    {
        "label": "aiofiles",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiofiles",
        "description": "aiofiles",
        "detail": "aiofiles",
        "documentation": {}
    },
    {
        "label": "search",
        "importPath": "googlesearch",
        "description": "googlesearch",
        "isExtraImport": true,
        "detail": "googlesearch",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "app.tool.run",
        "description": "app.tool.run",
        "isExtraImport": true,
        "detail": "app.tool.run",
        "documentation": {}
    },
    {
        "label": "tomllib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tomllib",
        "description": "tomllib",
        "detail": "tomllib",
        "documentation": {}
    },
    {
        "label": "APIError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncAzureOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AuthenticationError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAIError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "RateLimitError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "retry",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "stop_after_attempt",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "wait_random_exponential",
        "importPath": "tenacity",
        "description": "tenacity",
        "isExtraImport": true,
        "detail": "tenacity",
        "documentation": {}
    },
    {
        "label": "LLMSettings",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "importPath": "app.config",
        "description": "app.config",
        "isExtraImport": true,
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "Manus",
        "importPath": "app.agent.manus",
        "description": "app.agent.manus",
        "isExtraImport": true,
        "detail": "app.agent.manus",
        "documentation": {}
    },
    {
        "label": "Manus",
        "importPath": "app.agent.manus",
        "description": "app.agent.manus",
        "isExtraImport": true,
        "detail": "app.agent.manus",
        "documentation": {}
    },
    {
        "label": "FlowFactory",
        "importPath": "app.flow.flow_factory",
        "description": "app.flow.flow_factory",
        "isExtraImport": true,
        "detail": "app.flow.flow_factory",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "ui",
        "importPath": "nicegui",
        "description": "nicegui",
        "isExtraImport": true,
        "detail": "nicegui",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "Gui",
        "importPath": "taipy.gui",
        "description": "taipy.gui",
        "isExtraImport": true,
        "detail": "taipy.gui",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"OpenManus\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"OpenManus\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"OpenManus\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"OpenManus\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"OpenManus\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "BaseAgent",
        "kind": 6,
        "importPath": "app.agent.base",
        "description": "app.agent.base",
        "peekOfCode": "class BaseAgent(BaseModel, ABC):\n    \"\"\"Abstract base class for managing agent state and execution.\n    Provides foundational functionality for state transitions, memory management,\n    and a step-based execution loop. Subclasses must implement the `step` method.\n    \"\"\"\n    # Core attributes\n    name: str = Field(..., description=\"Unique name of the agent\")\n    description: Optional[str] = Field(None, description=\"Optional agent description\")\n    # Prompts\n    system_prompt: Optional[str] = Field(",
        "detail": "app.agent.base",
        "documentation": {}
    },
    {
        "label": "Manus",
        "kind": 6,
        "importPath": "app.agent.manus",
        "description": "app.agent.manus",
        "peekOfCode": "class Manus(ToolCallAgent):\n    \"\"\"\n    A versatile general-purpose agent that uses planning to solve various tasks.\n    This agent extends PlanningAgent with a comprehensive set of tools and capabilities,\n    including Python execution, web browsing, file operations, and information retrieval\n    to handle a wide range of user requests.\n    \"\"\"\n    name: str = \"Manus\"\n    description: str = (\n        \"A versatile agent that can solve various tasks using multiple tools\"",
        "detail": "app.agent.manus",
        "documentation": {}
    },
    {
        "label": "PlanningAgent",
        "kind": 6,
        "importPath": "app.agent.planning",
        "description": "app.agent.planning",
        "peekOfCode": "class PlanningAgent(ToolCallAgent):\n    \"\"\"\n    An agent that creates and manages plans to solve tasks.\n    This agent uses a planning tool to create and manage structured plans,\n    and tracks progress through individual steps until task completion.\n    \"\"\"\n    name: str = \"planning\"\n    description: str = \"An agent that creates and manages plans to solve tasks\"\n    system_prompt: str = PLANNING_SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_PROMPT",
        "detail": "app.agent.planning",
        "documentation": {}
    },
    {
        "label": "ReActAgent",
        "kind": 6,
        "importPath": "app.agent.react",
        "description": "app.agent.react",
        "peekOfCode": "class ReActAgent(BaseAgent, ABC):\n    name: str\n    description: Optional[str] = None\n    system_prompt: Optional[str] = None\n    next_step_prompt: Optional[str] = None\n    llm: Optional[LLM] = Field(default_factory=LLM)\n    memory: Memory = Field(default_factory=Memory)\n    state: AgentState = AgentState.IDLE\n    max_steps: int = 10\n    current_step: int = 0",
        "detail": "app.agent.react",
        "documentation": {}
    },
    {
        "label": "SWEAgent",
        "kind": 6,
        "importPath": "app.agent.swe",
        "description": "app.agent.swe",
        "peekOfCode": "class SWEAgent(ToolCallAgent):\n    \"\"\"An agent that implements the SWEAgent paradigm for executing code and natural conversations.\"\"\"\n    name: str = \"swe\"\n    description: str = \"an autonomous AI programmer that interacts directly with the computer to solve tasks.\"\n    system_prompt: str = SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_TEMPLATE\n    available_tools: ToolCollection = ToolCollection(\n        Bash(), StrReplaceEditor(), Terminate()\n    )\n    special_tool_names: List[str] = Field(default_factory=lambda: [Terminate().name])",
        "detail": "app.agent.swe",
        "documentation": {}
    },
    {
        "label": "ToolCallAgent",
        "kind": 6,
        "importPath": "app.agent.toolcall",
        "description": "app.agent.toolcall",
        "peekOfCode": "class ToolCallAgent(ReActAgent):\n    \"\"\"Base agent class for handling tool/function calls with enhanced abstraction\"\"\"\n    name: str = \"toolcall\"\n    description: str = \"an agent that can execute tool calls.\"\n    system_prompt: str = SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_PROMPT\n    available_tools: ToolCollection = ToolCollection(\n        CreateChatCompletion(), Terminate()\n    )\n    tool_choices: Literal[\"none\", \"auto\", \"required\"] = \"auto\"",
        "detail": "app.agent.toolcall",
        "documentation": {}
    },
    {
        "label": "TOOL_CALL_REQUIRED",
        "kind": 5,
        "importPath": "app.agent.toolcall",
        "description": "app.agent.toolcall",
        "peekOfCode": "TOOL_CALL_REQUIRED = \"Tool calls required but none provided\"\nclass ToolCallAgent(ReActAgent):\n    \"\"\"Base agent class for handling tool/function calls with enhanced abstraction\"\"\"\n    name: str = \"toolcall\"\n    description: str = \"an agent that can execute tool calls.\"\n    system_prompt: str = SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_PROMPT\n    available_tools: ToolCollection = ToolCollection(\n        CreateChatCompletion(), Terminate()\n    )",
        "detail": "app.agent.toolcall",
        "documentation": {}
    },
    {
        "label": "FlowType",
        "kind": 6,
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "peekOfCode": "class FlowType(str, Enum):\n    PLANNING = \"planning\"\nclass BaseFlow(BaseModel, ABC):\n    \"\"\"Base class for execution flows supporting multiple agents\"\"\"\n    agents: Dict[str, BaseAgent]\n    tools: Optional[List] = None\n    primary_agent_key: Optional[str] = None\n    class Config:\n        arbitrary_types_allowed = True\n    def __init__(",
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "BaseFlow",
        "kind": 6,
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "peekOfCode": "class BaseFlow(BaseModel, ABC):\n    \"\"\"Base class for execution flows supporting multiple agents\"\"\"\n    agents: Dict[str, BaseAgent]\n    tools: Optional[List] = None\n    primary_agent_key: Optional[str] = None\n    class Config:\n        arbitrary_types_allowed = True\n    def __init__(\n        self, agents: Union[BaseAgent, List[BaseAgent], Dict[str, BaseAgent]], **data\n    ):",
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "PlanStepStatus",
        "kind": 6,
        "importPath": "app.flow.base",
        "description": "app.flow.base",
        "peekOfCode": "class PlanStepStatus(str, Enum):\n    \"\"\"Enum class defining possible statuses of a plan step\"\"\"\n    NOT_STARTED = \"not_started\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    BLOCKED = \"blocked\"\n    @classmethod\n    def get_all_statuses(cls) -> list[str]:\n        \"\"\"Return a list of all possible step status values\"\"\"\n        return [status.value for status in cls]",
        "detail": "app.flow.base",
        "documentation": {}
    },
    {
        "label": "FlowFactory",
        "kind": 6,
        "importPath": "app.flow.flow_factory",
        "description": "app.flow.flow_factory",
        "peekOfCode": "class FlowFactory:\n    \"\"\"Factory for creating different types of flows with support for multiple agents\"\"\"\n    @staticmethod\n    def create_flow(\n        flow_type: FlowType,\n        agents: Union[BaseAgent, List[BaseAgent], Dict[str, BaseAgent]],\n        **kwargs,\n    ) -> BaseFlow:\n        flows = {\n            FlowType.PLANNING: PlanningFlow,",
        "detail": "app.flow.flow_factory",
        "documentation": {}
    },
    {
        "label": "PlanningFlow",
        "kind": 6,
        "importPath": "app.flow.planning",
        "description": "app.flow.planning",
        "peekOfCode": "class PlanningFlow(BaseFlow):\n    \"\"\"A flow that manages planning and execution of tasks using agents.\"\"\"\n    llm: LLM = Field(default_factory=lambda: LLM())\n    planning_tool: PlanningTool = Field(default_factory=PlanningTool)\n    executor_keys: List[str] = Field(default_factory=list)\n    active_plan_id: str = Field(default_factory=lambda: f\"plan_{int(time.time())}\")\n    current_step_index: Optional[int] = None\n    def __init__(\n        self, agents: Union[BaseAgent, List[BaseAgent], Dict[str, BaseAgent]], **data\n    ):",
        "detail": "app.flow.planning",
        "documentation": {}
    },
    {
        "label": "SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.manus",
        "description": "app.prompt.manus",
        "peekOfCode": "SYSTEM_PROMPT = \"You are OpenManus, an all-capable AI assistant, aimed at solving any task presented by the user. You have various tools at your disposal that you can call upon to efficiently complete complex requests. Whether it's programming, information retrieval, file processing, or web browsing, you can handle it all.\"\nNEXT_STEP_PROMPT = \"\"\"You can interact with the computer using PythonExecute, save important content and information files through FileSaver, open browsers with BrowserUseTool, and retrieve information using GoogleSearch.\nPythonExecute: Execute Python code to interact with the computer system, data processing, automation tasks, etc.\nFileSaver: Save files locally, such as txt, py, html, etc.\nBrowserUseTool: Open, browse, and use web browsers.If you open a local HTML file, you must provide the absolute path to the file.\nGoogleSearch: Perform web information retrieval\nTerminate: End the current interaction when the task is complete or when you need additional information from the user. Use this tool to signal that you've finished addressing the user's request or need clarification before proceeding further.\nBased on user needs, proactively select the most appropriate tool or combination of tools. For complex tasks, you can break down the problem and use different tools step by step to solve it. After using each tool, clearly explain the execution results and suggest the next steps.\nAlways maintain a helpful, informative tone throughout the interaction. If you encounter any limitations or need more details, clearly communicate this to the user before terminating.\n\"\"\"",
        "detail": "app.prompt.manus",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.manus",
        "description": "app.prompt.manus",
        "peekOfCode": "NEXT_STEP_PROMPT = \"\"\"You can interact with the computer using PythonExecute, save important content and information files through FileSaver, open browsers with BrowserUseTool, and retrieve information using GoogleSearch.\nPythonExecute: Execute Python code to interact with the computer system, data processing, automation tasks, etc.\nFileSaver: Save files locally, such as txt, py, html, etc.\nBrowserUseTool: Open, browse, and use web browsers.If you open a local HTML file, you must provide the absolute path to the file.\nGoogleSearch: Perform web information retrieval\nTerminate: End the current interaction when the task is complete or when you need additional information from the user. Use this tool to signal that you've finished addressing the user's request or need clarification before proceeding further.\nBased on user needs, proactively select the most appropriate tool or combination of tools. For complex tasks, you can break down the problem and use different tools step by step to solve it. After using each tool, clearly explain the execution results and suggest the next steps.\nAlways maintain a helpful, informative tone throughout the interaction. If you encounter any limitations or need more details, clearly communicate this to the user before terminating.\n\"\"\"",
        "detail": "app.prompt.manus",
        "documentation": {}
    },
    {
        "label": "PLANNING_SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.planning",
        "description": "app.prompt.planning",
        "peekOfCode": "PLANNING_SYSTEM_PROMPT = \"\"\"\nYou are an expert Planning Agent tasked with solving problems efficiently through structured plans.\nYour job is:\n1. Analyze requests to understand the task scope\n2. Create a clear, actionable plan that makes meaningful progress with the `planning` tool\n3. Execute steps using available tools as needed\n4. Track progress and adapt plans when necessary\n5. Use `finish` to conclude immediately when the task is complete\nAvailable tools will vary by task but may include:\n- `planning`: Create, update, and track plans (commands: create, update, mark_step, etc.)",
        "detail": "app.prompt.planning",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.planning",
        "description": "app.prompt.planning",
        "peekOfCode": "NEXT_STEP_PROMPT = \"\"\"\nBased on the current state, what's your next action?\nChoose the most efficient path forward:\n1. Is the plan sufficient, or does it need refinement?\n2. Can you execute the next step immediately?\n3. Is the task complete? If so, use `finish` right away.\nBe concise in your reasoning, then select the appropriate tool or action.\n\"\"\"",
        "detail": "app.prompt.planning",
        "documentation": {}
    },
    {
        "label": "SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.swe",
        "description": "app.prompt.swe",
        "peekOfCode": "SYSTEM_PROMPT = \"\"\"SETTING: You are an autonomous programmer, and you're working directly in the command line with a special interface.\nThe special interface consists of a file editor that shows you {{WINDOW}} lines of a file at a time.\nIn addition to typical bash commands, you can also use specific commands to help you navigate and edit files.\nTo call a command, you need to invoke it with a function call/tool call.\nPlease note that THE EDIT COMMAND REQUIRES PROPER INDENTATION.\nIf you'd like to add the line '        print(x)' you must fully write that out, with all those spaces before the code! Indentation is important and code that is not indented correctly will fail and require fixing before it can be run.\nRESPONSE FORMAT:\nYour shell prompt is formatted as follows:\n(Open file: <path>)\n(Current directory: <cwd>)",
        "detail": "app.prompt.swe",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_TEMPLATE",
        "kind": 5,
        "importPath": "app.prompt.swe",
        "description": "app.prompt.swe",
        "peekOfCode": "NEXT_STEP_TEMPLATE = \"\"\"{{observation}}\n(Open file: {{open_file}})\n(Current directory: {{working_dir}})\nbash-$\n\"\"\"",
        "detail": "app.prompt.swe",
        "documentation": {}
    },
    {
        "label": "SYSTEM_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.toolcall",
        "description": "app.prompt.toolcall",
        "peekOfCode": "SYSTEM_PROMPT = \"You are an agent that can execute tool calls\"\nNEXT_STEP_PROMPT = (\n    \"If you want to stop interaction, use `terminate` tool/function call.\"\n)",
        "detail": "app.prompt.toolcall",
        "documentation": {}
    },
    {
        "label": "NEXT_STEP_PROMPT",
        "kind": 5,
        "importPath": "app.prompt.toolcall",
        "description": "app.prompt.toolcall",
        "peekOfCode": "NEXT_STEP_PROMPT = (\n    \"If you want to stop interaction, use `terminate` tool/function call.\"\n)",
        "detail": "app.prompt.toolcall",
        "documentation": {}
    },
    {
        "label": "BaseTool",
        "kind": 6,
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "peekOfCode": "class BaseTool(ABC, BaseModel):\n    name: str\n    description: str\n    parameters: Optional[dict] = None\n    class Config:\n        arbitrary_types_allowed = True\n    async def __call__(self, **kwargs) -> Any:\n        \"\"\"Execute the tool with given parameters.\"\"\"\n        return await self.execute(**kwargs)\n    @abstractmethod",
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolResult",
        "kind": 6,
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "peekOfCode": "class ToolResult(BaseModel):\n    \"\"\"Represents the result of a tool execution.\"\"\"\n    output: Any = Field(default=None)\n    error: Optional[str] = Field(default=None)\n    system: Optional[str] = Field(default=None)\n    class Config:\n        arbitrary_types_allowed = True\n    def __bool__(self):\n        return any(getattr(self, field) for field in self.__fields__)\n    def __add__(self, other: \"ToolResult\"):",
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "CLIResult",
        "kind": 6,
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "peekOfCode": "class CLIResult(ToolResult):\n    \"\"\"A ToolResult that can be rendered as a CLI output.\"\"\"\nclass ToolFailure(ToolResult):\n    \"\"\"A ToolResult that represents a failure.\"\"\"\nclass AgentAwareTool:\n    agent: Optional = None",
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "ToolFailure",
        "kind": 6,
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "peekOfCode": "class ToolFailure(ToolResult):\n    \"\"\"A ToolResult that represents a failure.\"\"\"\nclass AgentAwareTool:\n    agent: Optional = None",
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "AgentAwareTool",
        "kind": 6,
        "importPath": "app.tool.base",
        "description": "app.tool.base",
        "peekOfCode": "class AgentAwareTool:\n    agent: Optional = None",
        "detail": "app.tool.base",
        "documentation": {}
    },
    {
        "label": "_BashSession",
        "kind": 6,
        "importPath": "app.tool.bash",
        "description": "app.tool.bash",
        "peekOfCode": "class _BashSession:\n    \"\"\"A session of a bash shell.\"\"\"\n    _started: bool\n    _process: asyncio.subprocess.Process\n    command: str = \"/bin/bash\"\n    _output_delay: float = 0.2  # seconds\n    _timeout: float = 120.0  # seconds\n    _sentinel: str = \"<<exit>>\"\n    def __init__(self):\n        self._started = False",
        "detail": "app.tool.bash",
        "documentation": {}
    },
    {
        "label": "Bash",
        "kind": 6,
        "importPath": "app.tool.bash",
        "description": "app.tool.bash",
        "peekOfCode": "class Bash(BaseTool):\n    \"\"\"A tool for executing bash commands\"\"\"\n    name: str = \"bash\"\n    description: str = _BASH_DESCRIPTION\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"command\": {\n                \"type\": \"string\",\n                \"description\": \"The bash command to execute. Can be empty to view additional logs when previous exit code is `-1`. Can be `ctrl+c` to interrupt the currently running process.\",",
        "detail": "app.tool.bash",
        "documentation": {}
    },
    {
        "label": "_BASH_DESCRIPTION",
        "kind": 5,
        "importPath": "app.tool.bash",
        "description": "app.tool.bash",
        "peekOfCode": "_BASH_DESCRIPTION = \"\"\"Execute a bash command in the terminal.\n* Long running commands: For commands that may run indefinitely, it should be run in the background and the output should be redirected to a file, e.g. command = `python3 app.py > server.log 2>&1 &`.\n* Interactive: If a bash command returns exit code `-1`, this means the process is not yet finished. The assistant must then send a second call to terminal with an empty `command` (which will retrieve any additional logs), or it can send additional text (set `command` to the text) to STDIN of the running process, or it can send command=`ctrl+c` to interrupt the process.\n* Timeout: If a command execution result says \"Command timed out. Sending SIGINT to the process\", the assistant should retry running the command in the background.\n\"\"\"\nclass _BashSession:\n    \"\"\"A session of a bash shell.\"\"\"\n    _started: bool\n    _process: asyncio.subprocess.Process\n    command: str = \"/bin/bash\"",
        "detail": "app.tool.bash",
        "documentation": {}
    },
    {
        "label": "BrowserUseTool",
        "kind": 6,
        "importPath": "app.tool.browser_use_tool",
        "description": "app.tool.browser_use_tool",
        "peekOfCode": "class BrowserUseTool(BaseTool):\n    name: str = \"browser_use\"\n    description: str = _BROWSER_DESCRIPTION\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"action\": {\n                \"type\": \"string\",\n                \"enum\": [\n                    \"navigate\",",
        "detail": "app.tool.browser_use_tool",
        "documentation": {}
    },
    {
        "label": "MAX_LENGTH",
        "kind": 5,
        "importPath": "app.tool.browser_use_tool",
        "description": "app.tool.browser_use_tool",
        "peekOfCode": "MAX_LENGTH = 2000\n_BROWSER_DESCRIPTION = \"\"\"\nInteract with a web browser to perform various actions such as navigation, element interaction,\ncontent extraction, and tab management. Supported actions include:\n- 'navigate': Go to a specific URL\n- 'click': Click an element by index\n- 'input_text': Input text into an element\n- 'screenshot': Capture a screenshot\n- 'get_html': Get page HTML content\n- 'get_text': Get text content of the page",
        "detail": "app.tool.browser_use_tool",
        "documentation": {}
    },
    {
        "label": "_BROWSER_DESCRIPTION",
        "kind": 5,
        "importPath": "app.tool.browser_use_tool",
        "description": "app.tool.browser_use_tool",
        "peekOfCode": "_BROWSER_DESCRIPTION = \"\"\"\nInteract with a web browser to perform various actions such as navigation, element interaction,\ncontent extraction, and tab management. Supported actions include:\n- 'navigate': Go to a specific URL\n- 'click': Click an element by index\n- 'input_text': Input text into an element\n- 'screenshot': Capture a screenshot\n- 'get_html': Get page HTML content\n- 'get_text': Get text content of the page\n- 'read_links': Get all links on the page",
        "detail": "app.tool.browser_use_tool",
        "documentation": {}
    },
    {
        "label": "CreateChatCompletion",
        "kind": 6,
        "importPath": "app.tool.create_chat_completion",
        "description": "app.tool.create_chat_completion",
        "peekOfCode": "class CreateChatCompletion(BaseTool):\n    name: str = \"create_chat_completion\"\n    description: str = (\n        \"Creates a structured completion with specified output formatting.\"\n    )\n    # Type mapping for JSON schema\n    type_mapping: dict = {\n        str: \"string\",\n        int: \"integer\",\n        float: \"number\",",
        "detail": "app.tool.create_chat_completion",
        "documentation": {}
    },
    {
        "label": "FileSaver",
        "kind": 6,
        "importPath": "app.tool.file_saver",
        "description": "app.tool.file_saver",
        "peekOfCode": "class FileSaver(BaseTool):\n    name: str = \"file_saver\"\n    description: str = \"\"\"Save content to a local file at a specified path.\nUse this tool when you need to save text, code, or generated content to a file on the local filesystem.\nThe tool accepts content and a file path, and saves the content to that location.\n\"\"\"\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"content\": {",
        "detail": "app.tool.file_saver",
        "documentation": {}
    },
    {
        "label": "GoogleSearch",
        "kind": 6,
        "importPath": "app.tool.google_search",
        "description": "app.tool.google_search",
        "peekOfCode": "class GoogleSearch(BaseTool):\n    name: str = \"google_search\"\n    description: str = \"\"\"Perform a Google search and return a list of relevant links.\nUse this tool when you need to find information on the web, get up-to-date data, or research specific topics.\nThe tool returns a list of URLs that match the search query.\n\"\"\"\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {",
        "detail": "app.tool.google_search",
        "documentation": {}
    },
    {
        "label": "PlanningTool",
        "kind": 6,
        "importPath": "app.tool.planning",
        "description": "app.tool.planning",
        "peekOfCode": "class PlanningTool(BaseTool):\n    \"\"\"\n    A planning tool that allows the agent to create and manage plans for solving complex tasks.\n    The tool provides functionality for creating plans, updating plan steps, and tracking progress.\n    \"\"\"\n    name: str = \"planning\"\n    description: str = _PLANNING_TOOL_DESCRIPTION\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {",
        "detail": "app.tool.planning",
        "documentation": {}
    },
    {
        "label": "_PLANNING_TOOL_DESCRIPTION",
        "kind": 5,
        "importPath": "app.tool.planning",
        "description": "app.tool.planning",
        "peekOfCode": "_PLANNING_TOOL_DESCRIPTION = \"\"\"\nA planning tool that allows the agent to create and manage plans for solving complex tasks.\nThe tool provides functionality for creating plans, updating plan steps, and tracking progress.\n\"\"\"\nclass PlanningTool(BaseTool):\n    \"\"\"\n    A planning tool that allows the agent to create and manage plans for solving complex tasks.\n    The tool provides functionality for creating plans, updating plan steps, and tracking progress.\n    \"\"\"\n    name: str = \"planning\"",
        "detail": "app.tool.planning",
        "documentation": {}
    },
    {
        "label": "PythonExecute",
        "kind": 6,
        "importPath": "app.tool.python_execute",
        "description": "app.tool.python_execute",
        "peekOfCode": "class PythonExecute(BaseTool):\n    \"\"\"A tool for executing Python code with timeout and safety restrictions.\"\"\"\n    name: str = \"python_execute\"\n    description: str = \"Executes Python code string. Note: Only print outputs are visible, function return values are not captured. Use print statements to see results.\"\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"code\": {\n                \"type\": \"string\",\n                \"description\": \"The Python code to execute.\",",
        "detail": "app.tool.python_execute",
        "documentation": {}
    },
    {
        "label": "maybe_truncate",
        "kind": 2,
        "importPath": "app.tool.run",
        "description": "app.tool.run",
        "peekOfCode": "def maybe_truncate(content: str, truncate_after: int | None = MAX_RESPONSE_LEN):\n    \"\"\"Truncate content and append a notice if content exceeds the specified length.\"\"\"\n    return (\n        content\n        if not truncate_after or len(content) <= truncate_after\n        else content[:truncate_after] + TRUNCATED_MESSAGE\n    )\nasync def run(\n    cmd: str,\n    timeout: float | None = 120.0,  # seconds",
        "detail": "app.tool.run",
        "documentation": {}
    },
    {
        "label": "StrReplaceEditor",
        "kind": 6,
        "importPath": "app.tool.str_replace_editor",
        "description": "app.tool.str_replace_editor",
        "peekOfCode": "class StrReplaceEditor(BaseTool):\n    \"\"\"A tool for executing bash commands\"\"\"\n    name: str = \"str_replace_editor\"\n    description: str = _STR_REPLACE_EDITOR_DESCRIPTION\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"command\": {\n                \"description\": \"The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`.\",\n                \"enum\": [\"view\", \"create\", \"str_replace\", \"insert\", \"undo_edit\"],",
        "detail": "app.tool.str_replace_editor",
        "documentation": {}
    },
    {
        "label": "maybe_truncate",
        "kind": 2,
        "importPath": "app.tool.str_replace_editor",
        "description": "app.tool.str_replace_editor",
        "peekOfCode": "def maybe_truncate(content: str, truncate_after: int | None = MAX_RESPONSE_LEN):\n    \"\"\"Truncate content and append a notice if content exceeds the specified length.\"\"\"\n    return (\n        content\n        if not truncate_after or len(content) <= truncate_after\n        else content[:truncate_after] + TRUNCATED_MESSAGE\n    )\nclass StrReplaceEditor(BaseTool):\n    \"\"\"A tool for executing bash commands\"\"\"\n    name: str = \"str_replace_editor\"",
        "detail": "app.tool.str_replace_editor",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 5,
        "importPath": "app.tool.str_replace_editor",
        "description": "app.tool.str_replace_editor",
        "peekOfCode": "Command = Literal[\n    \"view\",\n    \"create\",\n    \"str_replace\",\n    \"insert\",\n    \"undo_edit\",\n]\nSNIPPET_LINES: int = 4\nMAX_RESPONSE_LEN: int = 16000\nTRUNCATED_MESSAGE: str = \"<response clipped><NOTE>To save on context only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>\"",
        "detail": "app.tool.str_replace_editor",
        "documentation": {}
    },
    {
        "label": "_STR_REPLACE_EDITOR_DESCRIPTION",
        "kind": 5,
        "importPath": "app.tool.str_replace_editor",
        "description": "app.tool.str_replace_editor",
        "peekOfCode": "_STR_REPLACE_EDITOR_DESCRIPTION = \"\"\"Custom editing tool for viewing, creating and editing files\n* State is persistent across command calls and discussions with the user\n* If `path` is a file, `view` displays the result of applying `cat -n`. If `path` is a directory, `view` lists non-hidden files and directories up to 2 levels deep\n* The `create` command cannot be used if the specified `path` already exists as a file\n* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`\n* The `undo_edit` command will revert the last edit made to the file at `path`\nNotes for using the `str_replace` command:\n* The `old_str` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespaces!\n* If the `old_str` parameter is not unique in the file, the replacement will not be performed. Make sure to include enough context in `old_str` to make it unique\n* The `new_str` parameter should contain the edited lines that should replace the `old_str`",
        "detail": "app.tool.str_replace_editor",
        "documentation": {}
    },
    {
        "label": "Terminate",
        "kind": 6,
        "importPath": "app.tool.terminate",
        "description": "app.tool.terminate",
        "peekOfCode": "class Terminate(BaseTool):\n    name: str = \"terminate\"\n    description: str = _TERMINATE_DESCRIPTION\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\n                \"type\": \"string\",\n                \"description\": \"The finish status of the interaction.\",\n                \"enum\": [\"success\", \"failure\"],",
        "detail": "app.tool.terminate",
        "documentation": {}
    },
    {
        "label": "_TERMINATE_DESCRIPTION",
        "kind": 5,
        "importPath": "app.tool.terminate",
        "description": "app.tool.terminate",
        "peekOfCode": "_TERMINATE_DESCRIPTION = \"\"\"Terminate the interaction when the request is met OR if the assistant cannot proceed further with the task.\"\"\"\nclass Terminate(BaseTool):\n    name: str = \"terminate\"\n    description: str = _TERMINATE_DESCRIPTION\n    parameters: dict = {\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\n                \"type\": \"string\",\n                \"description\": \"The finish status of the interaction.\",",
        "detail": "app.tool.terminate",
        "documentation": {}
    },
    {
        "label": "ToolCollection",
        "kind": 6,
        "importPath": "app.tool.tool_collection",
        "description": "app.tool.tool_collection",
        "peekOfCode": "class ToolCollection:\n    \"\"\"A collection of defined tools.\"\"\"\n    def __init__(self, *tools: BaseTool):\n        self.tools = tools\n        self.tool_map = {tool.name: tool for tool in tools}\n    def __iter__(self):\n        return iter(self.tools)\n    def to_params(self) -> List[Dict[str, Any]]:\n        return [tool.to_param() for tool in self.tools]\n    async def execute(",
        "detail": "app.tool.tool_collection",
        "documentation": {}
    },
    {
        "label": "LLMSettings",
        "kind": 6,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "class LLMSettings(BaseModel):\n    model: str = Field(..., description=\"Model name\")\n    base_url: str = Field(..., description=\"API base URL\")\n    api_key: str = Field(..., description=\"API key\")\n    max_tokens: int = Field(4096, description=\"Maximum number of tokens per request\")\n    temperature: float = Field(1.0, description=\"Sampling temperature\")\n    api_type: str = Field(..., description=\"AzureOpenai or Openai\")\n    api_version: str = Field(..., description=\"Azure Openai version if AzureOpenai\")\nclass AppConfig(BaseModel):\n    llm: Dict[str, LLMSettings]",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "kind": 6,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "class AppConfig(BaseModel):\n    llm: Dict[str, LLMSettings]\nclass Config:\n    _instance = None\n    _lock = threading.Lock()\n    _initialized = False\n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "class Config:\n    _instance = None\n    _lock = threading.Lock()\n    _initialized = False\n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n        return cls._instance",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "get_project_root",
        "kind": 2,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "def get_project_root() -> Path:\n    \"\"\"Get the project root directory\"\"\"\n    return Path(__file__).resolve().parent.parent\nPROJECT_ROOT = get_project_root()\nWORKSPACE_ROOT = PROJECT_ROOT / \"workspace\"\nclass LLMSettings(BaseModel):\n    model: str = Field(..., description=\"Model name\")\n    base_url: str = Field(..., description=\"API base URL\")\n    api_key: str = Field(..., description=\"API key\")\n    max_tokens: int = Field(4096, description=\"Maximum number of tokens per request\")",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "kind": 5,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "PROJECT_ROOT = get_project_root()\nWORKSPACE_ROOT = PROJECT_ROOT / \"workspace\"\nclass LLMSettings(BaseModel):\n    model: str = Field(..., description=\"Model name\")\n    base_url: str = Field(..., description=\"API base URL\")\n    api_key: str = Field(..., description=\"API key\")\n    max_tokens: int = Field(4096, description=\"Maximum number of tokens per request\")\n    temperature: float = Field(1.0, description=\"Sampling temperature\")\n    api_type: str = Field(..., description=\"AzureOpenai or Openai\")\n    api_version: str = Field(..., description=\"Azure Openai version if AzureOpenai\")",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_ROOT",
        "kind": 5,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "WORKSPACE_ROOT = PROJECT_ROOT / \"workspace\"\nclass LLMSettings(BaseModel):\n    model: str = Field(..., description=\"Model name\")\n    base_url: str = Field(..., description=\"API base URL\")\n    api_key: str = Field(..., description=\"API key\")\n    max_tokens: int = Field(4096, description=\"Maximum number of tokens per request\")\n    temperature: float = Field(1.0, description=\"Sampling temperature\")\n    api_type: str = Field(..., description=\"AzureOpenai or Openai\")\n    api_version: str = Field(..., description=\"Azure Openai version if AzureOpenai\")\nclass AppConfig(BaseModel):",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "app.config",
        "description": "app.config",
        "peekOfCode": "config = Config()",
        "detail": "app.config",
        "documentation": {}
    },
    {
        "label": "ToolError",
        "kind": 6,
        "importPath": "app.exceptions",
        "description": "app.exceptions",
        "peekOfCode": "class ToolError(Exception):\n    \"\"\"Raised when a tool encounters an error.\"\"\"\n    def __init__(self, message):\n        self.message = message",
        "detail": "app.exceptions",
        "documentation": {}
    },
    {
        "label": "LLM",
        "kind": 6,
        "importPath": "app.llm",
        "description": "app.llm",
        "peekOfCode": "class LLM:\n    _instances: Dict[str, \"LLM\"] = {}\n    def __new__(\n        cls, config_name: str = \"default\", llm_config: Optional[LLMSettings] = None\n    ):\n        if config_name not in cls._instances:\n            instance = super().__new__(cls)\n            instance.__init__(config_name, llm_config)\n            cls._instances[config_name] = instance\n        return cls._instances[config_name]",
        "detail": "app.llm",
        "documentation": {}
    },
    {
        "label": "define_log_level",
        "kind": 2,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "def define_log_level(print_level=\"INFO\", logfile_level=\"DEBUG\", name: str = None):\n    \"\"\"Adjust the log level to above level\"\"\"\n    global _print_level\n    _print_level = print_level\n    current_date = datetime.now()\n    formatted_date = current_date.strftime(\"%Y%m%d%H%M%S\")\n    log_name = (\n        f\"{name}_{formatted_date}\" if name else formatted_date\n    )  # name a log with prefix name\n    _logger.remove()",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "_print_level",
        "kind": 5,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "_print_level = \"INFO\"\ndef define_log_level(print_level=\"INFO\", logfile_level=\"DEBUG\", name: str = None):\n    \"\"\"Adjust the log level to above level\"\"\"\n    global _print_level\n    _print_level = print_level\n    current_date = datetime.now()\n    formatted_date = current_date.strftime(\"%Y%m%d%H%M%S\")\n    log_name = (\n        f\"{name}_{formatted_date}\" if name else formatted_date\n    )  # name a log with prefix name",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "logger = define_log_level()\nif __name__ == \"__main__\":\n    logger.info(\"Starting application\")\n    logger.debug(\"Debug message\")\n    logger.warning(\"Warning message\")\n    logger.error(\"Error message\")\n    logger.critical(\"Critical message\")\n    try:\n        raise ValueError(\"Test error\")\n    except Exception as e:",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "AgentState",
        "kind": 6,
        "importPath": "app.schema",
        "description": "app.schema",
        "peekOfCode": "class AgentState(str, Enum):\n    \"\"\"Agent execution states\"\"\"\n    IDLE = \"IDLE\"\n    RUNNING = \"RUNNING\"\n    FINISHED = \"FINISHED\"\n    ERROR = \"ERROR\"\nclass Function(BaseModel):\n    name: str\n    arguments: str\nclass ToolCall(BaseModel):",
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "app.schema",
        "description": "app.schema",
        "peekOfCode": "class Function(BaseModel):\n    name: str\n    arguments: str\nclass ToolCall(BaseModel):\n    \"\"\"Represents a tool/function call in a message\"\"\"\n    id: str\n    type: str = \"function\"\n    function: Function\nclass Message(BaseModel):\n    \"\"\"Represents a chat message in the conversation\"\"\"",
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "ToolCall",
        "kind": 6,
        "importPath": "app.schema",
        "description": "app.schema",
        "peekOfCode": "class ToolCall(BaseModel):\n    \"\"\"Represents a tool/function call in a message\"\"\"\n    id: str\n    type: str = \"function\"\n    function: Function\nclass Message(BaseModel):\n    \"\"\"Represents a chat message in the conversation\"\"\"\n    role: Literal[\"system\", \"user\", \"assistant\", \"tool\"] = Field(...)\n    content: Optional[str] = Field(default=None)\n    tool_calls: Optional[List[ToolCall]] = Field(default=None)",
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Message",
        "kind": 6,
        "importPath": "app.schema",
        "description": "app.schema",
        "peekOfCode": "class Message(BaseModel):\n    \"\"\"Represents a chat message in the conversation\"\"\"\n    role: Literal[\"system\", \"user\", \"assistant\", \"tool\"] = Field(...)\n    content: Optional[str] = Field(default=None)\n    tool_calls: Optional[List[ToolCall]] = Field(default=None)\n    name: Optional[str] = Field(default=None)\n    tool_call_id: Optional[str] = Field(default=None)\n    def __add__(self, other) -> List[\"Message\"]:\n        \"\"\"支持 Message + list 或 Message + Message 的操作\"\"\"\n        if isinstance(other, list):",
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "Memory",
        "kind": 6,
        "importPath": "app.schema",
        "description": "app.schema",
        "peekOfCode": "class Memory(BaseModel):\n    messages: List[Message] = Field(default_factory=list)\n    max_messages: int = Field(default=100)\n    def add_message(self, message: Message) -> None:\n        \"\"\"Add a message to memory\"\"\"\n        self.messages.append(message)\n        # Optional: Implement message limit\n        if len(self.messages) > self.max_messages:\n            self.messages = self.messages[-self.max_messages :]\n    def add_messages(self, messages: List[Message]) -> None:",
        "detail": "app.schema",
        "documentation": {}
    },
    {
        "label": "check_winner",
        "kind": 2,
        "importPath": "tic_tac_toe",
        "description": "tic_tac_toe",
        "peekOfCode": "def check_winner():\n    winning_combinations = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n        [0, 4, 8], [2, 4, 6]               # Diagonals\n    ]\n    for combo in winning_combinations:\n        if board[combo[0]] == board[combo[1]] == board[combo[2]] and board[combo[0]] is not None:\n            return board[combo[0]]\n    if all(cell is not None for cell in board):",
        "detail": "tic_tac_toe",
        "documentation": {}
    },
    {
        "label": "button_click",
        "kind": 2,
        "importPath": "tic_tac_toe",
        "description": "tic_tac_toe",
        "peekOfCode": "def button_click(index):\n    global current_player, game_over\n    if board[index] is None and not game_over:\n        board[index] = current_player\n        buttons[index].text = current_player\n        winner = check_winner()\n        if winner:\n            game_over = True\n            if winner == 'Tie':\n                ui.notify('It\\'s a Tie!')",
        "detail": "tic_tac_toe",
        "documentation": {}
    },
    {
        "label": "reset_game",
        "kind": 2,
        "importPath": "tic_tac_toe",
        "description": "tic_tac_toe",
        "peekOfCode": "def reset_game():\n    global board, current_player, game_over\n    board = [None] * 9\n    current_player = 'X'\n    game_over = False\n    turn_label.text = f'Current turn: {current_player}'\n    for button in buttons:\n        button.text = ''\nwith ui.row():\n    turn_label = ui.label(f'Current turn: {current_player}')",
        "detail": "tic_tac_toe",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 5,
        "importPath": "tic_tac_toe",
        "description": "tic_tac_toe",
        "peekOfCode": "board = [None] * 9\ncurrent_player = 'X'\ngame_over = False\ndef check_winner():\n    winning_combinations = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n        [0, 4, 8], [2, 4, 6]               # Diagonals\n    ]\n    for combo in winning_combinations:",
        "detail": "tic_tac_toe",
        "documentation": {}
    },
    {
        "label": "current_player",
        "kind": 5,
        "importPath": "tic_tac_toe",
        "description": "tic_tac_toe",
        "peekOfCode": "current_player = 'X'\ngame_over = False\ndef check_winner():\n    winning_combinations = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n        [0, 4, 8], [2, 4, 6]               # Diagonals\n    ]\n    for combo in winning_combinations:\n        if board[combo[0]] == board[combo[1]] == board[combo[2]] and board[combo[0]] is not None:",
        "detail": "tic_tac_toe",
        "documentation": {}
    },
    {
        "label": "game_over",
        "kind": 5,
        "importPath": "tic_tac_toe",
        "description": "tic_tac_toe",
        "peekOfCode": "game_over = False\ndef check_winner():\n    winning_combinations = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns\n        [0, 4, 8], [2, 4, 6]               # Diagonals\n    ]\n    for combo in winning_combinations:\n        if board[combo[0]] == board[combo[1]] == board[combo[2]] and board[combo[0]] is not None:\n            return board[combo[0]]",
        "detail": "tic_tac_toe",
        "documentation": {}
    },
    {
        "label": "Todo",
        "kind": 6,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "class Todo:\n    def __init__(self, task, done=False):\n        self.task = task\n        self.done = done\n    def __repr__(self):  # for debugging purposes\n        return f\"Todo(task='{self.task}', done={self.done})\"\n# List to store to-do items\ntodos = []\n# Function to add a new task\ndef add_todo(state):",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "add_todo",
        "kind": 2,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "def add_todo(state):\n    new_todo = Todo(state.new_task)\n    state.todos.append(new_todo)\n    state.new_task = \"\"\n    update_dataframe(state)\n# Function to toggle the state of a todo\ndef toggle_todo(state, var_name, id, action):\n    state.todos[id].done = not state.todos[id].done\n    update_dataframe(state)\n# Function to update the dataframe",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "toggle_todo",
        "kind": 2,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "def toggle_todo(state, var_name, id, action):\n    state.todos[id].done = not state.todos[id].done\n    update_dataframe(state)\n# Function to update the dataframe\ndef update_dataframe(state):\n    data = [{\"Task\": todo.task, \"Done\": todo.done} for todo in state.todos]\n    state.df = pd.DataFrame(data)\n# Initial dataframe\ndata = [{\"Task\": todo.task, \"Done\": todo.done} for todo in todos]\ndf = pd.DataFrame(data)",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "update_dataframe",
        "kind": 2,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "def update_dataframe(state):\n    data = [{\"Task\": todo.task, \"Done\": todo.done} for todo in state.todos]\n    state.df = pd.DataFrame(data)\n# Initial dataframe\ndata = [{\"Task\": todo.task, \"Done\": todo.done} for todo in todos]\ndf = pd.DataFrame(data)\n# Taipy GUI definition\ngui_layout = \"\"\"\n< | {df} | table | on_action = toggle_todo | not editable = True | >\nNew task: < | {new_task} | text | label = \"Task name\" | >",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "todos",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "todos = []\n# Function to add a new task\ndef add_todo(state):\n    new_todo = Todo(state.new_task)\n    state.todos.append(new_todo)\n    state.new_task = \"\"\n    update_dataframe(state)\n# Function to toggle the state of a todo\ndef toggle_todo(state, var_name, id, action):\n    state.todos[id].done = not state.todos[id].done",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "data = [{\"Task\": todo.task, \"Done\": todo.done} for todo in todos]\ndf = pd.DataFrame(data)\n# Taipy GUI definition\ngui_layout = \"\"\"\n< | {df} | table | on_action = toggle_todo | not editable = True | >\nNew task: < | {new_task} | text | label = \"Task name\" | >\n< | Add | button | on_action = add_todo | >\n\"\"\"\n# Create the GUI\ngui = Gui(gui_layout)",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "df = pd.DataFrame(data)\n# Taipy GUI definition\ngui_layout = \"\"\"\n< | {df} | table | on_action = toggle_todo | not editable = True | >\nNew task: < | {new_task} | text | label = \"Task name\" | >\n< | Add | button | on_action = add_todo | >\n\"\"\"\n# Create the GUI\ngui = Gui(gui_layout)\n# Initialize the state",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "gui_layout",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "gui_layout = \"\"\"\n< | {df} | table | on_action = toggle_todo | not editable = True | >\nNew task: < | {new_task} | text | label = \"Task name\" | >\n< | Add | button | on_action = add_todo | >\n\"\"\"\n# Create the GUI\ngui = Gui(gui_layout)\n# Initialize the state\ngui.state.todos = todos\ngui.state.df = df",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "gui",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "gui = Gui(gui_layout)\n# Initialize the state\ngui.state.todos = todos\ngui.state.df = df\ngui.state.new_task = \"\"\n# Run the GUI\ngui.run()",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "gui.state.todos",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "gui.state.todos = todos\ngui.state.df = df\ngui.state.new_task = \"\"\n# Run the GUI\ngui.run()",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "gui.state.df",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "gui.state.df = df\ngui.state.new_task = \"\"\n# Run the GUI\ngui.run()",
        "detail": "to-do",
        "documentation": {}
    },
    {
        "label": "gui.state.new_task",
        "kind": 5,
        "importPath": "to-do",
        "description": "to-do",
        "peekOfCode": "gui.state.new_task = \"\"\n# Run the GUI\ngui.run()",
        "detail": "to-do",
        "documentation": {}
    }
]